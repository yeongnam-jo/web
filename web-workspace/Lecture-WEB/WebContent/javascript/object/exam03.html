<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
<script>
	var person = {
		'name' 	: '홍길동',
		'phone' : '010-1111-2222',
		'name' 	: '홍길동',
		'phone' : '010-1111-2222'
	}
	
	var person2 = {
		'name' 	: '윤길동',
		'phone' : '010-3333-4444',
		'addr'  : '서울시 서초구'	 
	}
	
	var persons = [person, person2];
	
	
	for(let index in persons) {
		let p = persons[index]
		for(let key in p){
			//document.write(`name : ${ p.name }, phone : ${ p.phone }<br>`)
			document.write(`${key} : ${p[key]} <br>`)
		}
	}

	////////////////////////////////////////////////////
	// persons는 배열이다. 배열의 요소가 객체다 : {}, {}
	var persons = [{
		'name' 	: '홍길동',
		'phone' : '010-1111-2222'
		
	}, {
		'name' 	: '윤길동',
		'phone' : '010-3333-4444',
		'addr'  : '서울시 서초구'	 
	}]
	
	alert(typeof persons); // 왜 타입이 object로 뜰까?
	
	// 배열은 스택 명령어와 동일하다. push, pop으로 추가 제거한다.
	// 배열에 객체를 하나 추가한다.
	persons.push({ 
		
		'name' 	: '임길동',
		'phone' : '010-6666-7777'
		
	})
	
	/* 이렇게 내용부를 쓸 필요가 없지. stack은 가장 마지막에 들어온 것이 무조건 먼저 삭제될테니까!!
	
	persons.pop({ 
		
		'name' 	: '임길동',
		'phone' : '010-6666-7777'
		
	});
	*/
	
	persons.pop();
	
	
	alert("시작됩니다========");
	for(let index in persons) {
		let p = persons[index]
		for(let key in p){
			
			alert("p.속성명 형태 가능한가");
			alert(`${key} : ${ p.key } <br>`);
			//document.write(`name : ${ p.name }, phone : ${ p.phone }<br>`);
			alert("p[속성명] 형태 가능한가");
			alert(`${key} : ${p[key]} <br>`);
			//document.write(`${key} : ${p[key]} <br>`);
		}
	}
	
	for(var i = 1; i <= 2; i++){
		var one = 10;
		let two = 20;
		const three = 30;
		alert(one);
		
	}
	
	alert('one 나올까요 <br>')
	alert(one); // 나옵니다. 호이스팅 되기 때문입니다. 즉, 지역변수로 선언해도 전역변수로 쓰일 수 있지요.
	alert('two 나올까요 <br>')
	alert(two); // 안나옵니다.
	alert('three 나올까요 <br>')
	alert(three); // 안나옵니다.
	
	
/* 	var one = 10;
	var one = 20;
	
	let two = 10;
	two = 20;
	let two = 30;
	
	const three = 10;
	three = 20; */
	
	
	
</script>
</head>
<body>

</body>
</html>